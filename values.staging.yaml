# Default values for jitsi-meet.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

global:
  podLabels: {}
  podAnnotations: {}
imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

enableAuth: false
enableGuests: true
publicURL: "https://call.taskade.dev"

tz: UTC

image:
  pullPolicy: IfNotPresent

websockets:
  ## Colibri (JVB signalling):
  colibri:
    enabled: true
  ## XMPP (Prosody signalling):
  xmpp:
    enabled: true

web:
  replicaCount: 1
  image:
    repository: jitsi/web
    tag: stable-8252

  extraEnvs: {}
  service:
    type: NodePort
    port: 80
    externalIPs: []

  ingress:
    enabled: true
    annotations:
      kubernetes.io/ingress.class: alb
      alb.ingress.kubernetes.io/scheme: internet-facing
      alb.ingress.kubernetes.io/tags: Environment=staging
      alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:us-east-1:843776460877:certificate/67578e82-72a9-41aa-b1f1-e37608c55150
      alb.ingress.kubernetes.io/actions.ssl-redirect: '{"Type": "redirect", "RedirectConfig": { "Protocol": "HTTPS", "Port": "443", "StatusCode": "HTTP_301"}}'
      alb.ingress.kubernetes.io/load-balancer-attributes: access_logs.s3.enabled=true,access_logs.s3.bucket=taskade-staging-jitsi-alb,access_logs.s3.prefix=jitsi
    hosts:
    - host: call.taskade.dev
      paths: ['/*']
    tls: []
    #  - secretName: jitsi-web-certificate
    #    hosts:
    #      - jitsi.local

  # Useful for ingresses that don't support http-to-https redirect by themself, (namely: GKE),
  httpRedirect: false

  # When tls-termination by the ingress is not wanted, enable this and set web.service.type=Loadbalancer
  httpsEnabled: false

  livenessProbe:
    httpGet:
      path: /
      port: 80
    timeoutSeconds: 3
  readinessProbe:
    httpGet:
      path: /
      port: 80
    timeoutSeconds: 3

  podLabels: {}
  podAnnotations: {}
  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  nodeSelector:
    eks.amazonaws.com/nodegroup: taskade-dev-node-group-20200605-jitsi-m5-large

  tolerations: []

  affinity: {}

jicofo:
  replicaCount: 1
  image:
    repository: jitsi/jicofo
    tag: stable-8252

  xmpp:
    user: focus
    password:
    componentSecret:

  livenessProbe:
    tcpSocket:
      port: 8888
    timeoutSeconds: 3
  readinessProbe:
    tcpSocket:
      port: 8888
    timeoutSeconds: 3

  podLabels: {}
  podAnnotations: {}
  podSecurityContext: {}
  securityContext: {}
  resources: {}
  nodeSelector:
    eks.amazonaws.com/nodegroup: taskade-dev-node-group-20200605-jitsi-m5-large
  tolerations: []
  affinity: {}
  extraEnvs: {}

jvb:
  replicaCount: 1
  image:
    repository: jitsi/jvb
    tag: stable-8252

  xmpp:
    user: jvb
    password:

  stunServers: 'meet-jit-si-turnrelay.jitsi.net:443'
  useHostPort: false
  enableTCP: true
  UDPPort: 30030
  TCPPort: 30443
  publicIPs:
    - jvb-staging-b1639615a9319053.elb.us-east-1.amazonaws.com
  service:
    enabled:
    type: NodePort
    externalIPs: []

  breweryMuc: jvbbrewery

  livenessProbe:
    httpGet:
      path: /about/health
      port: 8080
  readinessProbe:
    httpGet:
      path: /about/health
      port: 8080

  podLabels: {}
  podAnnotations: {}
  podSecurityContext: {}
  securityContext: {}
  resources: {}
  nodeSelector:
    eks.amazonaws.com/nodegroup: taskade-dev-node-group-20200605-jitsi-m5-large
  tolerations: []
  affinity: {}
  extraEnvs:
    JVB_STUN_SERVERS: "stun.l.google.com:19302,stun1.l.google.com:19302,stun2.l.google.com:19302"
    JVB_ENABLE_APIS: "rest,colibri"
    ENABLE_STATISTICS: "true"
  metrics:
    enabled: true
    prometheusAnnotations: true
    # image:
      # repository: docker.io/systemli/prometheus-jitsi-meet-exporter
      # tag: 1.2.1
      # pullPolicy: IfNotPresent
    # serviceMonitor:
      # enabled: false
      # selector:
        # release: prometheus-operator
      # interval: 10s
      # # honorLabels: false
    # resources:
      # requests:
        # cpu: 10m
        # memory: 16Mi
      # limits:
        # cpu: 20m
        # memory: 32Mi

octo:
  enabled: false

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name:

xmpp:
  domain: jitsi.svc.cluster.local
  authDomain:
  mucDomain:
  internalMucDomain:
  guestDomain:

extraCommonEnvs: {}
  # XMPP_CROSS_DOMAIN: "true"
  # ENABLE_LETSENCRYPT: "1"
  # LETSENCRYPT_DOMAIN: "call.taskade.dev"
  # LETSENCRYPT_EMAIL: "yc@taskade.com"

  # JVB_WS_SERVER_ID: "jitsi-prosody.jitsi.svc"
  # ENABLE_COLIBRI_WEBSOCKET: "0"

prosody:
  enabled: true
  server: jitsi-prosody.jitsi.svc.cluster.local
  extraEnvFrom:
  - secretRef:
      name: '{{ include "prosody.fullname" . }}-jicofo'
  - secretRef:
      name: '{{ include "prosody.fullname" . }}-jvb'
  - configMapRef:
      name: '{{ include "prosody.fullname" . }}-common'
  image:
    repository: jitsi/prosody
    tag: stable-8252
  nodeSelector:
    eks.amazonaws.com/nodegroup: taskade-dev-node-group-20200605-jitsi-m5-large
